########################################################################
# database interface code
try:
    conn_string = "host='limsdb2' dbname='lims2' user='atlasreader' password='atlasro'"
    conn = psycopg2.connect(conn_string)
    cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
except:
    print "-------------------------"
    print "Unable to connect to LIMS"
    raise

def specimen_id_from_name(name):
    global cursor
    cursor.execute("SELECT id FROM specimens WHERE name ilike '%%%s%%'" % name)
    result = cursor.fetchall()
    if len(result) > 0 and len(result[0]) > 0:
        return str(result[0][0])

# returns whether cell is human or mouse, or LGN
def specimen_category(spec_id):
    global cursor
    sql = """
    select o.name from specimens cell
    join donors d on d.id = cell.donor_id
    join organisms o on o.id = d.organism_id
    where cell.id =
    """
    lgn_sql = """
    select o.name from specimens cell
    join specimens slice on slice.id = cell.parent_id
    join donors d on d.id = cell.donor_id
    join organisms o on o.id = d.organism_id
    join tissue_processings tp on tp.id = slice.tissue_processing_id
    join tcp_sops tsop on tsop.id = tp.tcp_sop_id
    where tsop.name ilike '%LGN%'
    and cell.id =
    """
    cursor.execute(lgn_sql + spec_id)
    result = cursor.fetchall()
    if len(result) > 0 and len(result[0]) > 0:
        return CATEGORY_LGN
    #
    cursor.execute(sql + spec_id)
    result = cursor.fetchall()
    if len(result) > 0 and len(result[0]) > 0:
        species = result[0][0]
        if species == "Mus musculus":
            return CATEGORY_MOUSE
        elif species == "Homo Sapiens":
            return CATEGORY_HUMAN
    return CATEGORY_UNKNOWN


#
########################################################################

def get_spec_id(filename):
    m = re.compile("\d{9}\.swc")
    obj = m.search(filename)
    if obj is not None:
        try:
            return str(obj.group()[:-4])
        except:
            pass
    m = re.compile("\d{6}\.\d\d\.\d\d\.\d\d")
    obj = m.search(filename)
    if obj is not None:
        return specimen_id_from_name(obj.group())
    return None


def align_and_scale_neuron(nrn, units):
    if units == 'pixels':
        PIXEL_SCALE = dict(x=0.113, 
                           y=0.113, 
                           z=3* 0.113, 
                           r=0.113)
        print("scaling by %s" % str(PIXEL_SCALE))

        # convert to micron scale
        for n in nrn.node_list:
            n.x *= PIXEL_SCALE['x']
            n.y *= PIXEL_SCALE['y']
            n.z *= PIXEL_SCALE['z']
            n.radius *= PIXEL_SCALE['r']

    elif units == 'microns':
        MICRON_Z_SCALE = 3
        print("scaling z axis by %f" % MICRON_Z_SCALE)
        # scale z axis
        for n in nrn.node_list:
            n.z *= MICRON_Z_SCALE
    else:
        print("neuron has unknown units (%s) - no scaling applied." % units)

    # set soma to origin
    soma = nrn.soma_root()
    dx = soma.x
    dy = soma.y
    dz = soma.z
    for n in nrn.node_list:
        n.x -= dx
        n.y -= dy
        n.z -= dz
    # apply affine
    try:
        aff = prep_upright.calculate_transform(cursor, spec_id, nrn)
    except:
        print("no upright transform available for specimen %d" % spec_id)
        aff = None
    
    return nrn, aff

# copy from master pixel storage to upright directory (or non-upright) and
#   convert to micron scale
    

def copy_to_upright(nrn, aff, paths, base_file_name):
    # see where cell should be routed to
    if aff is not None:
        nrn.apply_affine(aff)
        upright_file = os.path.join(paths['upright'], base_file_name)
        print("Saving %s to upright directory" % upright_file)
        nrn.save(upright_file)
        inbound_file = os.path.join(path['upright_to_process'], base_file_name)
        print("Saving %s to upright directory" % inbound_file)
        nrn.save(inbound_file)
    else:
        raw_file = os.path.join(paths['non_upright'], base_file_name)
        print("Saving %s to non-upright directory" % raw_file)
        nrn.save(raw_file)
        inbound_file = os.path.join(path['non_upright_to_process'], base_file_name)
        print("Saving %s to non-upright inbound directory" % raw_file)
        nrn.save(inbound_file)


def swc_units(file_name):
    if len(file_name.split("_p")) > 1:
        return "pixels"
    elif len(file_name.split("_m")) > 1:
        return "microns"
    else:
        print "file %s not a recognized pixel or micron file" % file_name

def storage_paths(storage_dir):
    morph_base = os.path.join(storage_dir, 'morphology_data')

    return {
        CATEGORY_MOUSE: {
            'autotrace': os.path.join(morph_base, 'mouse', 'autotrace'),
            'upright': os.path.join(morph_base, 'mouse', 'swc'),
            'non_upright': os.path.join(morph_base, 'mouse', 'swc', 'non_upright'),
            'upright_to_process': os.path.join(morph_base, 'mouse', 'to_process'),
            'non_upright_to_process': os.path.join(morph_base, 'mouse', 'to_process', 'non_upright'), 
            'features': os.path.join(morph_base, 'mouse', 'features'),
            'html': os.path.join(morph_base, 'mouse', 'html')
        },
        CATEGORY_HUMAN: {
            'autotrace': os.path.join(morph_base, 'human', 'autotrace'),
            'upright': os.path.join(morph_base, 'human', 'swc'),
            'non_upright': os.path.join(morph_base, 'human', 'swc', 'non_upright'),
            'upright_to_process': os.path.join(morph_base, 'human', 'to_process'),
            'non_upright_to_process': os.path.join(morph_base, 'human', 'to_process', 'non_upright'),  
            'features': os.path.join(morph_base, 'human', 'features'),
            'html': os.path.join(morph_base, 'human', 'html')
            },
        CATEGORY_LGN: {
            }
        }

CATEGORY_MOUSE = "Mouse"
CATEGORY_HUMAN = "Human"
CATEGORY_UNKNOWN = "Unrecognized"
CATEGORY_LGN = "LGN"
